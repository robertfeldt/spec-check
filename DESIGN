1. Why we have to explicitly state when something is an expectation that should be checked?
-------------------------------------------------------------------------------------------
The simplest possible specing framework would allow any expressions that evaluates to
true or false to be used as spec cases. This would allow code like:

  (check 
    (= 1 1)
    (not= 1 2))

to run two spec cases. However the problem with this design is in cases like

  (check
    (let [a 10 b 20]
      (= (+ a 10) b)
      (not= a (- b 10))
      (= true (every? #(= 0 (rem %1 2)) [2 a b]))
      (= false (string? 1))))

where the value from the first expression in the let binding would not be returned
to the check function and thus would be missed. Thus we have decided that one must
always explicitly state that an expression is an expectation. In most situations
you will do this by usiing is or isnt:

  (check
    (let [a 10 b 20]
      (is = (+ a 10) b)
      (isnt not= a (- b 10))
      (is true? (every? #(= 0 (rem %1 2)) [0 2 4 6 8]))
      (is false? (string? 1))))
  
With this design we can then easily add a function to check that a 
sequence of forms are all spec cases and should all return a specific value:

  (check (all-are true?
    (= 1 1)
    (not= 1 2)))